"use strict";
/**
 * @module botbuilder-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageServiceUtils = void 0;
const httpRequestUtils_1 = require("./httpRequestUtils");
const __1 = require("..");
const rankerTypes_1 = require("../qnamaker-interfaces/rankerTypes");
const ApiVersionQueryParam = 'api-version=2021-10-01';
/**
 * Utilities for using Query Knowledge Base and Add Active Learning feedback APIs of language service.
 *
 * @summary
 * This class is helper class for query-knowledgebases api, used to make queries to a Language service project and returns the knowledgebase answers.
 */
class LanguageServiceUtils {
    /**
     * Creates new Language Service utils.
     *
     * @param {QnAMakerOptions} _options Settings used to configure the instance.
     * @param {QnAMakerEndpoint} endpoint The endpoint of the knowledge base to query.
     */
    constructor(_options, endpoint) {
        this._options = _options;
        this.endpoint = endpoint;
        this.httpRequestUtils = new httpRequestUtils_1.HttpRequestUtils();
        this.validateOptions(this._options);
    }
    /**
     * Adds feedback to the knowledge base.
     *
     * @param feedbackRecords A list of Feedback Records for Active Learning.
     * @returns {Promise<void>} A promise representing the async operation.
     */
    addFeedback(feedbackRecords) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!feedbackRecords) {
                throw new TypeError('Feedback records can not be null.');
            }
            if (!feedbackRecords.feedbackRecords || feedbackRecords.feedbackRecords.length == 0) {
                return;
            }
            yield this.addFeedbackRecordsToKnowledgebase(feedbackRecords.feedbackRecords);
        });
    }
    /**
     * Called to query the Language service.
     *
     * @param {string} question Question which need to be queried.
     * @param {QnAMakerOptions} options (Optional) The options for the QnA Maker knowledge base. If null, constructor option is used for this instance.
     * @returns {Promise<QnAMakerResult[]>} a promise that resolves to the raw query results
     */
    queryKnowledgebaseRaw(question, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const deploymentName = options.isTest ? 'test' : 'production';
            const url = `${this.endpoint.host}/language/:query-knowledgebases?projectName=${this.endpoint.knowledgeBaseId}&deploymentName=${deploymentName}&${ApiVersionQueryParam}`;
            const queryOptions = Object.assign(Object.assign({}, this._options), options);
            queryOptions.rankerType = !queryOptions.rankerType ? rankerTypes_1.RankerTypes.default : queryOptions.rankerType;
            this.validateOptions(queryOptions);
            const payloadBody = JSON.stringify({
                question: question,
                confidenceScoreThreshold: queryOptions.scoreThreshold,
                top: queryOptions.top,
                filters: this.getFilters(queryOptions.strictFilters, queryOptions.strictFiltersJoinOperator, queryOptions.filters),
                qnaId: queryOptions.qnaId,
                rankerType: queryOptions.rankerType,
                context: queryOptions.context,
                answerSpanRequest: { enable: queryOptions.enablePreciseAnswer },
                includeUnstructuredSources: queryOptions.includeUnstructuredSources,
            });
            const qnaResults = yield this.httpRequestUtils.executeHttpRequest(url, payloadBody, this.endpoint, queryOptions.timeout);
            if (Array.isArray(qnaResults === null || qnaResults === void 0 ? void 0 : qnaResults.answers)) {
                return this.formatQnaResult(qnaResults);
            }
            throw new Error(`Failed to query knowledgebase: ${qnaResults}`);
        });
    }
    /**
     * Emits a trace event detailing a Custom Question Answering call and its results.
     *
     * @param {TurnContext} turnContext Turn Context for the current turn of conversation with the user.
     * @param {QnAMakerResult[]} answers Answers returned by Language Service.
     * @param {QnAMakerOptions} queryOptions (Optional) The options for the Custom Question Answering knowledge base. If null, constructor option is used for this instance.
     * @returns {Promise<any>} a promise representing the async operation
     */
    emitTraceInfo(turnContext, answers, queryOptions
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = Object.assign(Object.assign({}, this._options), queryOptions);
            const { scoreThreshold, top, strictFilters, metadataBoost, context, qnaId } = requestOptions;
            const traceInfo = {
                message: turnContext.activity,
                queryResults: answers,
                knowledgeBaseId: this.endpoint.knowledgeBaseId,
                scoreThreshold,
                top,
                strictFilters,
                metadataBoost,
                context,
                qnaId,
            };
            return turnContext.sendActivity({
                type: 'trace',
                valueType: __1.QNAMAKER_TRACE_TYPE,
                name: __1.QNAMAKER_TRACE_NAME,
                label: __1.QNAMAKER_TRACE_LABEL,
                value: traceInfo,
            });
        });
    }
    /**
     * Validate qna maker options
     *
     * @param {QnAMakerOptions} options The options for the Custom Question Answering knowledge base. If null, constructor option is used for this instance.
     */
    validateOptions(options) {
        const { scoreThreshold, top } = options;
        if (scoreThreshold) {
            this.validateScoreThreshold(scoreThreshold);
        }
        if (top) {
            this.validateTop(top);
        }
    }
    formatQnaResult(kbAnswers) {
        var _a;
        const qnaResultsAnswers = (_a = kbAnswers.answers) === null || _a === void 0 ? void 0 : _a.map((kbAnswer) => {
            var _a, _b, _c;
            const qnaResult = {
                answer: kbAnswer.answer,
                score: kbAnswer.confidenceScore,
                metadata: kbAnswer.metadata
                    ? (_a = Array.from(kbAnswer.metadata)) === null || _a === void 0 ? void 0 : _a.map((nv) => {
                        return { name: nv[0], value: nv[1] };
                    }) : null,
                answerSpan: (kbAnswer === null || kbAnswer === void 0 ? void 0 : kbAnswer.answerSpan) ? {
                    text: kbAnswer.answerSpan.text,
                    score: kbAnswer.answerSpan.confidenceScore,
                    startIndex: kbAnswer.answerSpan.offset,
                    endIndex: kbAnswer.answerSpan.offset + kbAnswer.answerSpan.length - 1,
                }
                    : null,
                context: (kbAnswer === null || kbAnswer === void 0 ? void 0 : kbAnswer.dialog) ? {
                    prompts: (_c = (_b = kbAnswer.dialog) === null || _b === void 0 ? void 0 : _b.prompts) === null || _c === void 0 ? void 0 : _c.map((p) => {
                        return {
                            displayOrder: p.displayOrder,
                            displayText: p.displayText,
                            qna: null,
                            qnaId: p.qnaId,
                        };
                    }),
                }
                    : null,
                id: kbAnswer.id,
                questions: kbAnswer.questions,
                source: kbAnswer.source,
            };
            return qnaResult;
        });
        const qnaResults = { answers: qnaResultsAnswers, activeLearningEnabled: true };
        return qnaResults;
    }
    validateScoreThreshold(scoreThreshold) {
        if (typeof scoreThreshold !== 'number' || !(scoreThreshold > 0 && scoreThreshold <= 1)) {
            throw new TypeError(`"${scoreThreshold}" is an invalid scoreThreshold. QnAMakerOptions.scoreThreshold must have a value between 0 and 1.`);
        }
    }
    validateTop(qnaOptionTop) {
        if (!Number.isInteger(qnaOptionTop) || qnaOptionTop < 1) {
            throw new RangeError(`"${qnaOptionTop}" is an invalid top value. QnAMakerOptions.top must be an integer greater than 0.`);
        }
    }
    getFilters(strictFilters, metadataJoinOperator, filters) {
        if (filters) {
            return filters;
        }
        if (strictFilters) {
            const metadataKVPairs = [];
            strictFilters.forEach((filter) => {
                metadataKVPairs.push({ key: filter.name, value: filter.value });
            });
            const newFilters = {
                metadataFilter: {
                    metadata: metadataKVPairs,
                    logicalOperation: metadataJoinOperator ? metadataJoinOperator.toString() : __1.JoinOperator.AND,
                },
                sourceFilter: [],
                logicalOperation: __1.JoinOperator.AND.toString(),
            };
            return newFilters;
        }
        return null;
    }
    addFeedbackRecordsToKnowledgebase(records) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.endpoint.host}/language/query-knowledgebases/projects/${this.endpoint.knowledgeBaseId}/feedback?${ApiVersionQueryParam}`;
            const payloadBody = JSON.stringify({
                records: records,
            });
            yield this.httpRequestUtils.executeHttpRequest(url, payloadBody, this.endpoint);
        });
    }
}
exports.LanguageServiceUtils = LanguageServiceUtils;
//# sourceMappingURL=languageServiceUtils.js.map