"use strict";
/**
 * @module botbuilder-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomQuestionAnswering = exports.CQAClientKey = void 0;
const botbuilder_core_1 = require("botbuilder-core");
const qnamaker_interfaces_1 = require("./qnamaker-interfaces");
const qnamaker_utils_1 = require("./qnamaker-utils");
const languageServiceUtils_1 = require("./qnamaker-utils/languageServiceUtils");
const qnaTelemetryConstants_1 = require("./qnaTelemetryConstants");
/**
 * Turn state key for QnAMakerClient.
 */
exports.CQAClientKey = Symbol('QnAMakerClient');
/**
 * Query a Custom Question Answering knowledge base for answers and provide feedbacks.
 *
 * @summary
 * This class is used to make queries to a single QnA Maker knowledge base and return the result.
 *
 * Use this to process incoming messages with the [getAnswers()](#getAnswers) method.
 */
class CustomQuestionAnswering {
    /**
     * Creates a new CustomQuestionAnswering instance.
     *
     * @param {QnAMakerEndpoint} endpoint The endpoint of the knowledge base to query.
     * @param {QnAMakerOptions} options (Optional) additional settings used to configure the instance.
     * @param {BotTelemetryClient} telemetryClient The BotTelemetryClient used for logging telemetry events.
     * @param {boolean} logPersonalInformation Set to true to include personally indentifiable information in telemetry events.
     */
    constructor(endpoint, options = {}, telemetryClient, logPersonalInformation) {
        this.endpoint = endpoint;
        if (!endpoint) {
            throw new TypeError('QnAMaker requires valid QnAMakerEndpoint.');
        }
        const { scoreThreshold = 0.3, top = 1, strictFilters = [], metadataBoost = [], filters = undefined, timeout = 100000, rankerType = qnamaker_interfaces_1.RankerTypes.default, enablePreciseAnswer = true, includeUnstructuredSources = true, } = options;
        this._options = {
            scoreThreshold,
            top,
            strictFilters,
            metadataBoost,
            filters,
            timeout,
            rankerType,
            enablePreciseAnswer,
            includeUnstructuredSources,
        };
        this.languageServiceUtils = new languageServiceUtils_1.LanguageServiceUtils(this._options, this.endpoint);
        this._telemetryClient = telemetryClient || new botbuilder_core_1.NullTelemetryClient();
        this._logPersonalInformation = logPersonalInformation || false;
    }
    /**
     * Gets a value indicating whether determines whether to log personal information that came from the user.
     *
     * @returns True to determine whether to log personal information that came from the user; otherwise, false.
     */
    get logPersonalInformation() {
        return this._logPersonalInformation;
    }
    /**
     * Gets the currently configured BotTelemetryClient that logs the events.
     *
     * @returns Currently configured BotTelemetryClient that logs the events.
     */
    get telemetryClient() {
        return this._telemetryClient;
    }
    /**
     * Calls the Language service to generate answer(s) for a question.
     *
     * @summary
     * Returns an array of answers sorted by score with the top scoring answer returned first.
     *
     * In addition to returning the results from Language service, [getAnswers()](#getAnswers) will also
     * emit a trace activity that contains the query results.
     *
     * @param {TurnContext} context The Turn Context that contains the user question to be queried against your knowledge base.
     * @param {QnAMakerOptions} options (Optional) The options for the Custom Question Answering knowledge base. If null, constructor option is used for this instance.
     * @param {object} telemetryProperties Additional properties to be logged to telemetry with the QnaMessage event.
     * @param {object} telemetryMetrics Additional metrics to be logged to telemetry with the QnaMessage event.
     * @returns {Promise<QnAMakerResult>} A promise resolving to the QnAMaker result
     */
    getAnswers(context, options, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context) {
                throw new TypeError('QnAMaker.getAnswers() requires a TurnContext.');
            }
            const response = yield this.getAnswersRaw(context, options, telemetryProperties, telemetryMetrics);
            if (!response) {
                return [];
            }
            return response.answers;
        });
    }
    /**
     * Generates an answer from the knowledge base.
     *
     * @param {TurnContext} context The [TurnContext](xref:botbuilder-core.TurnContext) that contains the user question to be queried against your knowledge base.
     * @param {QnAMakerOptions} options Optional. The [QnAMakerOptions](xref:botbuilder-ai.QnAMakerOptions) for the Custom Question Answering knowledge base. If null, constructor option is used for this instance.
     * @param {object} telemetryProperties Optional. Additional properties to be logged to telemetry with the QnaMessage event.
     * @param {object} telemetryMetrics Optional. Additional metrics to be logged to telemetry with the QnaMessage event.
     * @returns {Promise<QnAMakerResults>} A list of answers for the user query, sorted in decreasing order of ranking score.
     */
    getAnswersRaw(context, options, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context) {
                throw new TypeError('CustomQuestionAnswering.getAnswersRaw() requires a TurnContext.');
            }
            const response = yield this.getKnowledgebaseAnswersRaw(context, options, telemetryProperties, telemetryMetrics);
            return response;
        });
    }
    /**
     * Queries for answers from the Language Service project's knowledge base.
     *
     * @param {TurnContext} context The [TurnContext](xref:botbuilder-core.TurnContext) that contains the user question to be queried against your knowledge base.
     * @param {QnAMakerOptions} options Optional. The [QnAMakerOptions](xref:botbuilder-ai.QnAMakerOptions) for the Language Service project's knowledge base. If null, constructor option is used for this instance.
     * @param {object} telemetryProperties Optional. Additional properties to be logged to telemetry with the QnaMessage event.
     * @param {object} telemetryMetrics Optional. Additional metrics to be logged to telemetry with the QnaMessage event.
     * @returns {Promise<QnAMakerResults>} A list of answers for the user query, sorted in decreasing order of ranking score.
     */
    getKnowledgebaseAnswersRaw(context, options, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            const question = this.getTrimmedMessageText(context);
            const queryOptions = Object.assign(Object.assign({}, this._options), options);
            let result;
            if (question.length > 0) {
                result = yield this.languageServiceUtils.queryKnowledgebaseRaw(question, queryOptions);
            }
            else {
                throw new RangeError('Question cannot be null or empty text');
            }
            if (!result) {
                return result;
            }
            yield Promise.all([
                // Log telemetry
                this.onQnaResults(result.answers, context, telemetryProperties, telemetryMetrics),
                this.languageServiceUtils.emitTraceInfo(context, result.answers, queryOptions),
            ]);
            return result;
        });
    }
    /**
     * Filters the ambiguous question for active learning.
     *
     * @summary Returns a filtered array of ambiguous question.
     *
     * @param {QnAMakerResult[]} queryResult User query output.
     * @returns {QnAMakerResult[]} the filtered results
     */
    getLowScoreVariation(queryResult) {
        return qnamaker_utils_1.ActiveLearningUtils.getLowScoreVariation(queryResult);
    }
    /**
     * Send feedback to the knowledge base.
     *
     * @param feedbackRecords  FeedbackRecords for Active Learning.
     * @returns {Promise<void>} A promise representing the async operation.
     */
    callTrain(feedbackRecords) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.languageServiceUtils.addFeedback(feedbackRecords);
        });
    }
    /**
     * Invoked prior to a QnaMessage Event being logged.
     *
     * @param {QnAMakerResult[]} qnaResults The QnA Results for the call.
     * @param {TurnContext} turnContext Context object containing information for a single turn of conversation with a user.
     * @param {object} telemetryProperties Additional properties to be logged to telemetry with the QnaMessage event.
     * @param {object} telemetryMetrics Additional metrics to be logged to telemetry with the QnaMessage event.
     * @returns {Promise<void>} A promise representing the async operation
     */
    onQnaResults(qnaResults, turnContext, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            const [properties, metrics] = yield this.fillQnAEvent(qnaResults, turnContext, telemetryProperties, telemetryMetrics);
            this.telemetryClient.trackEvent({
                name: qnaTelemetryConstants_1.QnATelemetryConstants.qnaMessageEvent,
                properties,
                metrics,
            });
        });
    }
    /**
     * Fills the event properties for QnaMessage event for telemetry.
     * These properties are logged when the recognizer is called.
     *
     * @param {QnAMakerResult[]} qnaResults Last activity sent from user.
     * @param {TurnContext} turnContext Context object containing information for a single turn of conversation with a user.
     * @param {object} telemetryProperties Additional properties to be logged to telemetry with the QnaMessage event.
     * @param {object} telemetryMetrics Additional properties to be logged to telemetry with the QnaMessage event.
     * @returns {Promise<[object, object]>} A dictionary that is sent as properties to BotTelemetryClient.trackEvent method for the QnaMessage event.
     */
    fillQnAEvent(qnaResults, turnContext, telemetryProperties, telemetryMetrics) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            const properties = {
                [qnaTelemetryConstants_1.QnATelemetryConstants.knowledgeBaseIdProperty]: this.endpoint.knowledgeBaseId,
            };
            const metrics = {};
            const text = (_a = turnContext.activity) === null || _a === void 0 ? void 0 : _a.text;
            const userName = (_c = (_b = turnContext.activity) === null || _b === void 0 ? void 0 : _b.from) === null || _c === void 0 ? void 0 : _c.name;
            // Use the LogPersonalInformation flag to toggle logging PII data, text is a common example
            if (this.logPersonalInformation) {
                if (text) {
                    properties[qnaTelemetryConstants_1.QnATelemetryConstants.questionProperty] = text;
                }
                if (userName) {
                    properties[qnaTelemetryConstants_1.QnATelemetryConstants.usernameProperty] = userName;
                }
            }
            // Fill in Qna Results (found or not)
            const [queryResult] = qnaResults;
            Object.assign(properties, {
                [qnaTelemetryConstants_1.QnATelemetryConstants.matchedQuestionProperty]: (_d = JSON.stringify(queryResult === null || queryResult === void 0 ? void 0 : queryResult.questions)) !== null && _d !== void 0 ? _d : 'No Qna Question matched',
                [qnaTelemetryConstants_1.QnATelemetryConstants.questionIdProperty]: (_f = (_e = queryResult === null || queryResult === void 0 ? void 0 : queryResult.id) === null || _e === void 0 ? void 0 : _e.toString()) !== null && _f !== void 0 ? _f : 'No Qna Question Id matched',
                [qnaTelemetryConstants_1.QnATelemetryConstants.answerProperty]: (_g = queryResult === null || queryResult === void 0 ? void 0 : queryResult.answer) !== null && _g !== void 0 ? _g : 'No Qna Answer matched',
                [qnaTelemetryConstants_1.QnATelemetryConstants.articleFoundProperty]: JSON.stringify(queryResult != null),
            });
            if (queryResult) {
                metrics[qnaTelemetryConstants_1.QnATelemetryConstants.scoreMetric] = queryResult.score;
            }
            // Additional Properties can override "stock" properties.
            if (telemetryProperties) {
                Object.assign(properties, telemetryProperties);
            }
            // Additional Metrics can override "stock" metrics.
            if (telemetryMetrics) {
                Object.assign(metrics, telemetryMetrics);
            }
            return [properties, metrics];
        });
    }
    // Gets the message from the Activity in the TurnContext, trimmed of whitespaces.
    getTrimmedMessageText(context) {
        var _a, _b, _c;
        return (_c = (_b = (_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.text) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : '';
    }
}
exports.CustomQuestionAnswering = CustomQuestionAnswering;
//# sourceMappingURL=customQuestionAnswering.js.map