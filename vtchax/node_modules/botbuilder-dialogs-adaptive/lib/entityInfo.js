"use strict";
/**
 * @module botbuilder-dialogs-adaptive
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityInfo = void 0;
/**
 * Extended information about an entity including $instance data.
 */
class EntityInfo {
    /**
     * Print an entity as a string.
     *
     * @param source Source entity.
     * @returns A string that represents the current object.
     */
    static toString(source) {
        return `${source.name}:${source.value} P${source.priority} ${source.score} ${source.coverage}`;
    }
    /**
     * Returns true if entities share text in utterance.
     *
     * @param source Source entity.
     * @param entity Entity to compare.
     * @returns True if entities share text in utterance, otherwise false.
     */
    static overlaps(source, entity) {
        return source.start <= entity.end && source.end >= entity.start;
    }
    /**
     * Returns true if entities come from exactly the same text in the utterance.
     *
     * @param source Source entity.
     * @param entity Entity to compare.
     * @returns True if entities come from the exactly same text in utterance, otherwise false.
     */
    static alternative(source, entity) {
        return source.start == entity.start && source.end == entity.end;
    }
    /**
     * Returns true entity text completely includes another entity text.
     *
     * @param source Source entity.
     * @param entity Entity to compare.
     * @returns True if the entity text completely includes another entity text, otherwise false.
     */
    static covers(source, entity) {
        return (source.start <= entity.start &&
            source.end >= entity.end &&
            source.end - source.start > entity.end - entity.start);
    }
    /**
     * Returns true if entities share the same root.
     *
     * @param source Source entity.
     * @param entity Entity to compare.
     * @returns True if entities share the same root, otherwise false.
     */
    static sharesRoot(source, entity) {
        return source.rootEntity === entity.rootEntity;
    }
    /**
     * Returns true if entities are the same.
     *
     * @param source Source entity.
     * @param entity Entity to compare.
     * @returns True if entities are the same, otherwise false.
     */
    static isSameEntity(source, entity) {
        return EntityInfo.sharesRoot(source, entity) && EntityInfo.alternative(source, entity);
    }
    /**
     * @private
     * Remove any entities that overlap a selected entity.
     * @param source Source entity.
     * @param entities Normalized set of entities to modify.
     */
    static removeOverlappingEntities(source, entities) {
        for (const name in entities) {
            const infos = entities[name];
            if (Array.isArray(infos)) {
                entities[name] = infos.filter((e) => !EntityInfo.overlaps(e, source));
            }
        }
    }
}
exports.EntityInfo = EntityInfo;
//# sourceMappingURL=entityInfo.js.map