"use strict";
/**
 * @module botbuilder-dialogs-adaptive
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecognizerSet = void 0;
const botbuilder_1 = require("botbuilder");
const converters_1 = require("../converters");
const adaptiveRecognizer_1 = require("./adaptiveRecognizer");
const telemetryLoggerConstants_1 = require("../telemetryLoggerConstants");
/**
 * A recognizer class whose result is the union of results from multiple recognizers into one RecognizerResult.
 */
class RecognizerSet extends adaptiveRecognizer_1.AdaptiveRecognizer {
    constructor() {
        super(...arguments);
        this.recognizers = [];
    }
    /**
     * @param property The key of the conditional selector configuration.
     * @returns The converter for the selector configuration.
     */
    getConverter(property) {
        switch (property) {
            case 'recognizers':
                return converters_1.RecognizerListConverter;
            default:
                return super.getConverter(property);
        }
    }
    /**
     * Runs current DialogContext.TurnContext.Activity through a recognizer and returns a [RecognizerResult](xref:botbuilder-core.RecognizerResult).
     *
     * @param dialogContext The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param activity [Activity](xref:botframework-schema.Activity) to recognize.
     * @param telemetryProperties Optional, additional properties to be logged to telemetry with the LuisResult event.
     * @param telemetryMetrics Optional, additional metrics to be logged to telemetry with the LuisResult event.
     * @returns {Promise<RecognizerResult>} Analysis of utterance.
     */
    recognize(dialogContext, activity, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Promise.all(this.recognizers.map((recognizer) => {
                return recognizer.recognize(dialogContext, activity, telemetryProperties, telemetryMetrics);
            }));
            const recognizerResult = this.mergeResults(results);
            this.trackRecognizerResult(dialogContext, telemetryLoggerConstants_1.TelemetryLoggerConstants.RecognizerSetResultEvent, this.fillRecognizerResultTelemetryProperties(recognizerResult, telemetryProperties, dialogContext), telemetryMetrics);
            return recognizerResult;
        });
    }
    mergeResults(results) {
        var _a, _b, _c;
        var _d, _e;
        const mergedRecognizerResult = {
            text: undefined,
            alteredText: undefined,
            intents: {},
            entities: {
                $instance: {},
            },
        };
        for (const result of results) {
            const { intent: intentName } = botbuilder_1.getTopScoringIntent(result);
            if (intentName && intentName !== 'None') {
                // merge text
                if (!mergedRecognizerResult.text) {
                    mergedRecognizerResult.text = result.text;
                }
                else if (result.text !== mergedRecognizerResult.text) {
                    mergedRecognizerResult.alteredText = result.text;
                }
                // merge intents
                for (const [intentName, intent] of Object.entries(result.intents)) {
                    const intentScore = (_a = intent.score) !== null && _a !== void 0 ? _a : 0;
                    if (Object.hasOwnProperty.call(mergedRecognizerResult.intents, intentName)) {
                        if (intentScore < mergedRecognizerResult.intents[intentName].score) {
                            // we already have a higher score for this intent
                            continue;
                        }
                    }
                    mergedRecognizerResult.intents[intentName] = intent;
                }
            }
            // merge entities
            // entities shape is:
            //   {
            //      "name": ["value1","value2","value3"],
            //      "$instance": {
            //          "name": [ { "startIndex" : 15, ... }, ... ]
            //      }
            //   }
            if (result.entities) {
                for (const [propertyName, propertyVal] of Object.entries(result.entities)) {
                    if (propertyName === '$instance') {
                        for (const [entityName, entityValue] of Object.entries(propertyVal)) {
                            const mergedInstanceEntities = ((_b = (_d = mergedRecognizerResult.entities['$instance'])[entityName]) !== null && _b !== void 0 ? _b : (_d[entityName] = []));
                            mergedInstanceEntities.push(...entityValue);
                        }
                    }
                    else {
                        const mergedEntities = ((_c = (_e = mergedRecognizerResult.entities)[propertyName]) !== null && _c !== void 0 ? _c : (_e[propertyName] = []));
                        mergedEntities.push(...propertyVal);
                    }
                }
            }
            for (const property in result) {
                if (property != 'text' &&
                    property != 'alteredText' &&
                    property != 'intents' &&
                    property != 'entities') {
                    // naive merge clobbers same key.
                    mergedRecognizerResult[property] = result[property];
                }
            }
        }
        if (Object.entries(mergedRecognizerResult.intents).length === 0) {
            mergedRecognizerResult.intents['None'] = { score: 1.0 };
        }
        return mergedRecognizerResult;
    }
}
exports.RecognizerSet = RecognizerSet;
RecognizerSet.$kind = 'Microsoft.RecognizerSet';
//# sourceMappingURL=recognizerSet.js.map