"use strict";
/**
 * @module botbuilder-dialogs-adaptive
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiLanguageRecognizer = void 0;
const languagePolicy_1 = require("../languagePolicy");
const converters_1 = require("../converters");
const languageGeneratorExtensions_1 = require("../languageGeneratorExtensions");
const adaptiveRecognizer_1 = require("./adaptiveRecognizer");
const telemetryLoggerConstants_1 = require("../telemetryLoggerConstants");
/**
 * Defines map of languages -> recognizer.
 */
class MultiLanguageRecognizer extends adaptiveRecognizer_1.AdaptiveRecognizer {
    /**
     * @param property The key of the conditional selector configuration.
     * @returns The converter for the selector configuration.
     */
    getConverter(property) {
        switch (property) {
            case 'languagePolicy':
                return new languagePolicy_1.LanguagePolicyConverter();
            case 'recognizers':
                return converters_1.MultiLanguageRecognizerConverter;
            default:
                return super.getConverter(property);
        }
    }
    /**
     * Runs current DialogContext.TurnContext.Activity through a recognizer and returns a [RecognizerResult](xref:botbuilder-core.RecognizerResult).
     *
     * @param dialogContext The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param activity [Activity](xref:botframework-schema.Activity) to recognize.
     * @param telemetryProperties Optional, additional properties to be logged to telemetry with the LuisResult event.
     * @param telemetryMetrics Optional, additional metrics to be logged to telemetry with the LuisResult event.
     * @returns {Promise<RecognizerResult>} Analysis of utterance.
     */
    recognize(dialogContext, activity, telemetryProperties, telemetryMetrics) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let languagepolicy = this.languagePolicy;
            if (!languagepolicy) {
                languagepolicy = dialogContext.services.get(languageGeneratorExtensions_1.languagePolicyKey);
                if (!languagepolicy) {
                    languagepolicy = new languagePolicy_1.LanguagePolicy();
                }
            }
            const locale = ((_a = activity.locale) !== null && _a !== void 0 ? _a : '').toLowerCase();
            const policy = [];
            if (languagepolicy.has(locale)) {
                policy.push(...languagepolicy.get(locale));
            }
            if (locale !== '' && languagepolicy.has('')) {
                // we now explictly add defaultPolicy instead of coding that into target's policy
                policy.push(...languagepolicy.get(''));
            }
            const lowercaseRecognizerKeyLookup = Object.keys(this.recognizers).reduce((acc, key) => {
                acc[key.toLowerCase()] = key;
                return acc;
            }, {});
            for (const option of policy) {
                const recognizerKey = lowercaseRecognizerKeyLookup[option.toLowerCase()];
                if (recognizerKey !== undefined) {
                    const recognizer = this.recognizers[recognizerKey];
                    const result = yield recognizer.recognize(dialogContext, activity, telemetryProperties, telemetryMetrics);
                    this.trackRecognizerResult(dialogContext, telemetryLoggerConstants_1.TelemetryLoggerConstants.MultiLanguageRecognizerResultEvent, this.fillRecognizerResultTelemetryProperties(result, telemetryProperties, dialogContext), telemetryMetrics);
                    return result;
                }
            }
            const recognizerResult = {
                text: activity.text || '',
                intents: {},
                entities: {},
            };
            this.trackRecognizerResult(dialogContext, telemetryLoggerConstants_1.TelemetryLoggerConstants.MultiLanguageRecognizerResultEvent, this.fillRecognizerResultTelemetryProperties(recognizerResult, telemetryProperties, dialogContext), telemetryMetrics);
            return recognizerResult;
        });
    }
}
exports.MultiLanguageRecognizer = MultiLanguageRecognizer;
MultiLanguageRecognizer.$kind = 'Microsoft.MultiLanguageRecognizer';
//# sourceMappingURL=multiLanguageRecognizer.js.map